# TiSds

## Лабораторная работа №1. Вариант №5

Смоделировать операцию умножения действительного числа на действительное число 
в форме ±m.n Е ±K, где суммарная длина мантиссы первого сомножителя (m+n) - до
35 значащих цифр, второго – до 40 значащих цифр, а величина порядка K - до 5 цифр. 
Результат выдать в форме ±0.m1 Е ±K1, где m1 – до 40 значащих цифр, а K1 - до 5 цифр.

### Принцип работы

В процессе решения, очевидно, необходимо использовать "кастомный" тип данный, позволяющий хранить числа, превыщающие возможности стандартных типов данных яыка C. В данном решении используется следующая интерпретация:

```c
typedef struct 
{
    int mantiss[MAX_MANTISS_LENGTH];
    int mant_size;
    int order;
    bool mant_sign;
} lfloat_t;
```

Логически программа разделена следующие блоки:
* вывод инструкций по использованию программы
* ввод двух чисел типа lfloat_t с консоли и их парсинг из строки в структуру
* перемножение введенных чисел
* вывод результата перемножения в нормализованном виде

#### Рассмотрим ввод числа типа lfloat_t

Согласно условию число можно вводить по-разному. Допустимы следующие форматы ввода:
* ```123```
* ```123.456```
* ```.00025```
* ```+123001.```
* ```-123.456```
* ```1234567 Е -20```

В самом длинном варианте ввода число будет иметь следующий вид: ```+-m.n E +-K```

В процессе записи данных в структуру может возникнуть проблема, которая повлечет за собой проблемы с рассчетом порядка, поэтому очень важно определить формат записи и хранения данных заранее. О чем я говорю? В нормальной научной экспоненциальной форме записи ЧПТ число записывается как $N = M * n^p$, например:

```
1000000 -> 1E6
1201000 -> 1.201E6
0.038 -> 38E-3
```

Во всех этих примерах (и как правило) перед знаком $E$ пишется целая часть (т.е. она выделяется), затем дробная часть (если есть), а затем уже порядок (после E). Однако по условия ЛР вывод результата должен быть таким: $±0.m1 Е ±K1$, то есть целой части не должно быть:

```
1000000 -> +0.1E+7
1201000 -> +0.1201E+7
0.038 -> +0.38E-1
```

В этой связи может появиться путанница при записи данных в структуру и достаточно философский вопрос: от какого "места" считать порядок? А число 0.123 должно в памяти лежать как [1, 2, 3] с порядком 0 или -1? В процессе написания ЛР я столкнулась с последствиями своего небрежного парсинга чисел разной формы записи. Ваш парсер, естественно, числа записанные в "обычной" форме и в "научной" форме парсить будет с разным подходом. Вот именно на этом моменте очень важно проследить, чтобы порядки и в том и в другом случае корректно обрабатывались и помещались в структуру. Иными словами, если логически вы вводите два одинаковых числа, у которых различна форма, следите за тем, как обрабатываются их порядки, чтобы избежать, например, такого:

```
Ввод: 0.01

====== PARSED RESULT ======
--> reversed_mantiss: 1 
--> mantiss_size: 1
--> mantiss_sign: 1
--> order: -1

Ввод: 1E-2

====== PARSED RESULT ======
--> reversed_mantiss: 1 
--> mantiss_size: 1
--> mantiss_sign: 1
--> order: -2
```

Образующая функция ввода - ```lffloat_string_parse```. Рассмотрим принцип ее работы:

```c
// NOTE === ОБРАБОТКА ЗНАКА МАНТИССЫ И ВЕДУЩИХ НУЛЕЙ ===
if (*ptr == '+')
    ptr++;
else if (*ptr == '-')
{
    ptr++;
    lfnum->mant_sign = false;
}
```

Первое что необходимо обработать: знак мантиссы (при наличии). По умолчанию в результирующую структуру вносится информация о положительной мантиссе (знак "+"), однако если в начале строки встречается "-", то ```lfnum->mant_sign = false;```

```c
while ((*ptr == '0' || *ptr == '.') && *status == SUCCESS_CODE)
{
    if (*ptr == '0')
        (point_encountered) ? lead_zrs_after_point++ : lead_zrs_before_point++;
    else 
    {
        if (!point_encountered)
            point_encountered = true;
        else 
            *status = INVALID_CHARACTER;
    }

    ptr++;         
}      
```

Далее проходимся по числам после знака мантиссы, пока не достигнем любого символа, отличного от ```0``` или ```.```. Это необходимо для того, чтобы определить есть ли вообще у введенного числа целая часть и посчитать лидирующие нули до точки (lead_zrs_before_point) и лидирующие нули после точки (lead_zrs_after_point). Далее это знание необходимо при рассчете итогового порядка для нормализованного вида мантиссы. Также необходимо заметить, что наличие более чем одной точки является ошибкой, что предусмотрено в данном блоке.

```c
// NOTE === ПОИСК КОНЦА МАНТИССЫ И ПОДСЧЕТ ЕЕ ДЛИНЫ ===
const char *mantissa_start = ptr;  // Начало значащей части мантиссы
const char *mantissa_end = ptr - 1;  // Конец значащей части мантиссы
int mantissa_length = 0;
int digits_before_point = 0;  // Цифры до точки в значащей части (если есть)

while (*ptr != '\0' && *ptr != 'E' && *status == SUCCESS_CODE)
{
    if (*ptr >= '0' && *ptr <= '9')
    {
        if (!point_encountered)
            digits_before_point++;
        
        mantissa_end = ptr;
        mantissa_length++;
    }
    else if (*ptr == '.' && !point_encountered)
        point_encountered = true;
    else if (*ptr != ' ')
        *status = INVALID_CHARACTER;
    ptr++;
}
```

Блок кода выше отвечает за обработку данных, связанных непосредственно с мантиссой: ее длину, а также устанавливает указатель на ее конец. Как только достигается символ 'E' или конец строки, обработка переходит на новый этап.

```c
int write_index = mantissa_length - 1; // Записываем с конца массива
point_encountered = 0; // Сбрасываем для второго прохода

for (const char *curr = mantissa_start; curr <= mantissa_end; curr++) 
{
    if (*curr == '.')
        point_encountered = 1;
    else 
        lfnum->mantiss[write_index--] = *curr - '0';  // '5' - '0' => 53 - 48 = 5
}
lfnum->mant_size = mantissa_length;
```

После проверки ограничений размера мантиссы необходимо записать цифры мантиссы в массив. Необходимо делать это "в обратном порядке" для упрощения вычисления. Обход начинается с символа ```*mantissa_start``` до конца мантиссы ```*mantissa_end```. Каждая цифра мантиссы вычисляется удобный способом ```*curr - '0'```: вычисляется разность не самих ```char``` элементов, а их ASCII кодов. Таким образом, например, ```'5' - '0' => 53 - 48 = 5```.

```c
if (*ptr != 'E')
{
    if (mantissa_length > 0)
    {
        if (digits_before_point > 0)
            lfnum->order = digits_before_point;
        else
            lfnum->order = -lead_zrs_after_point - mantissa_length;
    }
    else
        lfnum->order = 0;
}
else
{
    while (*(++ptr) == ' ');

    if (*ptr == '-')
    {
        ptr++;
        order_sign = false;
    }
    else if (*ptr == '+')
        ptr++;
    
    // Пропуск ведущих нулей
    while (*ptr == '0')
        ptr++;

    // Чтение значения порядка
    const char *order_start = ptr;
    while (*ptr >= '0' && *ptr <= '9')
    {
        order_value = order_value * 10 + (*ptr - '0');
        order_digits_count++;
        ptr++;
    }

    if (order_digits_count == 0 && ptr == order_start)
        *status = NO_NUM_AFTER_E;  // Если после 'E' нет цифр
    else if (order_digits_count > MAX_ORDER_LENGTH)
        *status = ERR_ORDER_SIZE;  // Если порядок больше дозволенного
    
    // NOTE === ВЫЧИСЛЕНИЕ ИТОГОВОГО ПОРЯДКА ===
    if (*status == SUCCESS_CODE)
    {
        order_value = (order_sign) ? order_value : -order_value;  // Если знак порядка отрицательный, меняем значение 
        lfnum->order = (digits_before_point) ? digits_before_point + order_value : order_value - lead_zrs_after_point - mantissa_length;
    }
}
```

Разберем блок кода сверху. Порядок числа (```lfnum->order```) в случае, когда не указан символ E определяется в зависимости от:
* размера мантиссы (нет числа - нет порядка)
* цифрами перед точкой (целой частью): из порядка отнимаются нули после точки + количество цифр после точки

Строчка ```while (*(++ptr) == ' ');``` позволяет пропустить возможные пробелы в случае когда E указан. Далее определяется знак порядка, затем пропускаются все ведущию нули (они незначащие). Далее происходит чтение значение порядка. Тот факт, что порядок - целое число, значительно облегчает парсинг, поэтому мы ищем целые числа (```*ptr >= '0' && *ptr <= '9'```), пока не достигнем конца строки.

Далее идет ряд стандартных проверок, после чего ввод числа может быть окончен.
