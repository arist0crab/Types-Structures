## Лабораторная работа №1. Вариант №5

Смоделировать операцию умножения действительного числа на действительное число 
в форме ±m.n Е ±K, где суммарная длина мантиссы первого сомножителя (m+n) - до
35 значащих цифр, второго – до 40 значащих цифр, а величина порядка K - до 5 цифр. 
Результат выдать в форме ±0.m1 Е ±K1, где m1 – до 40 значащих цифр, а K1 - до 5 цифр.

---

### Принцип работы

В процессе решения, очевидно, необходимо использовать "кастомный" тип данный, позволяющий хранить числа, превыщающие возможности стандартных типов данных яыка C. В данном решении используется следующая интерпретация:

```c
typedef struct 
{
    int mantiss[MAX_MANTISS_LENGTH];
    int mant_size;
    int order;
    bool mant_sign;
} lfloat_t;
```

Логически программа разделена на следующие блоки:
* вывод инструкций по использованию программы
* ввод двух чисел типа lfloat_t с консоли и их парсинг из строки в структуру
* перемножение введенных чисел
* вывод результата перемножения в нормализованном виде

#### Рассмотрим ввод числа типа lfloat_t

Согласно условию число можно вводить по-разному. Допустимы следующие форматы ввода:
* ```123```
* ```123.456```
* ```.00025```
* ```+123001.```
* ```-123.456```
* ```1234567 Е -20```

В самом длинном варианте ввода число будет иметь следующий вид: ```+-m.n E +-K```

В процессе записи данных в структуру может возникнуть проблема, которая повлечет за собой проблемы с рассчетом порядка, поэтому очень важно определить формат записи и хранения данных заранее. О чем я говорю? В нормальной научной экспоненциальной форме записи ЧПТ число записывается как $N = M * n^p$, например:

```
1000000 -> 1E6
1201000 -> 1.201E6
0.038 -> 38E-3
```

Во всех этих примерах (и как правило) перед знаком $E$ пишется целая часть (т.е. она выделяется), затем дробная часть (если есть), а затем уже порядок (после E). Однако по условию ЛР вывод результата должен быть таким: $±0.m1 Е ±K1$, то есть целой части не должно быть:

```
1000000 -> +0.1E+7
1201000 -> +0.1201E+7
0.038 -> +0.38E-1
```

В этой связи может появиться путанница при записи данных в структуру и достаточно философский вопрос: от какого "места" считать порядок? А число 0.123 должно в памяти лежать как [1, 2, 3] с порядком 0 или -1? В процессе написания ЛР я столкнулась с последствиями своего небрежного парсинга чисел разной формы записи. Ваш парсер, естественно, числа записанные в "обычной" форме и в "научной" форме парсить будет с разным подходом. Вот именно на этом моменте очень важно проследить, чтобы порядки и в том и в другом случае корректно обрабатывались и помещались в структуру. Иными словами, если логически вы вводите два одинаковых числа, у которых различная форма, следите за тем, как обрабатываются их порядки, чтобы избежать, например, такого:

```
Ввод: 0.01

====== PARSED RESULT ======
--> reversed_mantiss: 1 
--> mantiss_size: 1
--> mantiss_sign: 1
--> order: -1

Ввод: 1E-2

====== PARSED RESULT ======
--> reversed_mantiss: 1 
--> mantiss_size: 1
--> mantiss_sign: 1
--> order: -2
```

---

Теперь рассмотрим образующую функцию ввода - ```lffloat_string_parse```:

```c
// NOTE === ОБРАБОТКА ЗНАКА МАНТИССЫ И ВЕДУЩИХ НУЛЕЙ ===
if (*ptr == '+')
    ptr++;
else if (*ptr == '-')
{
    ptr++;
    lfnum->mant_sign = false;
}
```

Первое что необходимо обработать: знак мантиссы (при наличии). По умолчанию в результирующую структуру вносится информация о положительной мантиссе (знак "+"), однако если в начале строки встречается "-", то ```lfnum->mant_sign = false;```

```c
while ((*ptr == '0' || *ptr == '.') && *status == SUCCESS_CODE)
{
    if (*ptr == '0')
        (point_encountered) ? lead_zrs_after_point++ : lead_zrs_before_point++;
    else 
    {
        if (!point_encountered)
            point_encountered = true;
        else 
            *status = INVALID_CHARACTER;
    }

    ptr++;         
}      
```

Далее проходимся по числам после знака мантиссы, пока не достигнем любого символа, отличного от ```0``` или ```.```. Это необходимо для того, чтобы определить есть ли вообще у введенного числа целая часть и посчитать лидирующие нули до точки (lead_zrs_before_point) и лидирующие нули после точки (lead_zrs_after_point). Далее это знание необходимо при рассчете итогового порядка для нормализованного вида мантиссы. Также необходимо заметить, что наличие более чем одной точки является ошибкой, что предусмотрено в данном блоке.

```c
// NOTE === ПОИСК КОНЦА МАНТИССЫ И ПОДСЧЕТ ЕЕ ДЛИНЫ ===
const char *mantissa_start = ptr;  // Начало значащей части мантиссы
const char *mantissa_end = ptr - 1;  // Конец значащей части мантиссы
int mantissa_length = 0;
int digits_before_point = 0;  // Цифры до точки в значащей части (если есть)

while (*ptr != '\0' && *ptr != 'E' && *status == SUCCESS_CODE)
{
    if (*ptr >= '0' && *ptr <= '9')
    {
        if (!point_encountered)
            digits_before_point++;
        
        mantissa_end = ptr;
        mantissa_length++;
    }
    else if (*ptr == '.' && !point_encountered)
        point_encountered = true;
    else if (*ptr != ' ')
        *status = INVALID_CHARACTER;
    ptr++;
}
```

Блок кода выше отвечает за обработку данных, связанных непосредственно с мантиссой: ее длину, а также устанавливает указатель на ее конец. Как только достигается символ 'E' или конец строки, обработка переходит на новый этап.

```c
int write_index = mantissa_length - 1; // Записываем с конца массива
point_encountered = 0; // Сбрасываем для второго прохода

for (const char *curr = mantissa_start; curr <= mantissa_end; curr++) 
{
    if (*curr == '.')
        point_encountered = 1;
    else 
        lfnum->mantiss[write_index--] = *curr - '0';  // '5' - '0' => 53 - 48 = 5
}
lfnum->mant_size = mantissa_length;
```

После проверки ограничений размера мантиссы необходимо записать цифры мантиссы в массив. Необходимо делать это "в обратном порядке" для упрощения вычисления. Обход начинается с символа ```*mantissa_start``` до конца мантиссы ```*mantissa_end```. Каждая цифра мантиссы вычисляется удобный способом ```*curr - '0'```: вычисляется разность не самих ```char``` элементов, а их ASCII кодов. Таким образом, например, ```'5' - '0' => 53 - 48 = 5```.

Далее возможны два варианта:
* в записи числа есть знак E (и степень числа после нее соответственно)
* в записи числа нет E

Рассмотрим вариант, при котором мы НЕ встречаем знак экспоненты:

```c
if (*ptr != 'E')
{
    if (mantissa_length > 0)
    {
        if (digits_before_point > 0)
            lfnum->order = digits_before_point;
        else
            lfnum->order = -lead_zrs_after_point; 
    }
    else
        lfnum->order = 0;
}
```

Согласно блоку кода выше, если ```mantissa_length == 0```, то мы считаем что был введен 0 и радостно присваиваем порядку значение 0. В противном случае обращаем свой взгляд на число. У нас есть число в точкой (а может быть без точки, смотря что было введено). Глобально возможны два варианта:
1. введенное число не содержит целой части (т.е. |num| < 1): ```0.1, .777, -0.2```
2. введенное число содержит целую часть (т.е. |num| >= 1): 1.1, ```-7282.0, 36.2, 3.03, 7```

В первом случае порядок числа определется целой частью: сколько цифр будет перед точкой, такой и будет порядок. Это имеет смысл: $12.345 = 0.12345 * 10^2$ ($10^2$ т.к. в целой части две цифры).

Во втором же случае порядок числа будет определяться количеством **лидирующих** нулей после точки. Например: $0.00404 = 0.404 * 10^{-2}$ (потому что после точки именно 2 лидирующих нуля).

```c
else  // (*ptr == 'E') 
{
    while (*(++ptr) == ' ');

    if (*ptr == '-')
    {
        ptr++;
        order_sign = false;
    }
    else if (*ptr == '+')
        ptr++;
    
    // Пропуск ведущих нулей
    while (*ptr == '0')
        ptr++;

    // Чтение значения порядка
    const char *order_start = ptr;
    while (*ptr >= '0' && *ptr <= '9')
    {
        order_value = order_value * 10 + (*ptr - '0');
        order_digits_count++;
        ptr++;
    }

    if (*ptr != '\0')  // Проверяем что ввод завершился именно концом строки, а не INVALID_CHARACTER
        *status = INVALID_CHARACTER;
    
    if (*status == SUCCESS_CODE)
    {
        if (order_digits_count == 0 && ptr == order_start)
            *status = NO_NUM_AFTER_E;  // Если после 'E' нет цифр
        else if (order_digits_count > MAX_ORDER_LENGTH)
            *status = ERR_ORDER_SIZE;  // Если порядок больше дозволенного
    }

    if (order_value > MAX_ORDER_VAL)
        *status = WRONG_ORDER_VALUE;
    
    // NOTE === ВЫЧИСЛЕНИЕ ИТОГОВОГО ПОРЯДКА ===
    if (*status == SUCCESS_CODE)
    {
        order_value = (order_sign) ? order_value : -order_value;  // Если знак порядка отрицательный, меняем значение 
        lfnum->order = (digits_before_point) ? digits_before_point + order_value : order_value - lead_zrs_after_point - mantissa_length;
    }
}
```

Рассмотрим тяжелый случай: к несчастью мы встретили знак экспоненты. Сначала с помощью ```while (*(++ptr) == ' ');``` пропускаем лишние пробелы. Далее происходит обработка знака порядка (подобный механизм мы видели при обработке знака мантиссы). После пропуска ведущих нулей необходимо считать сам порядок. Ввод порядка заканчивается там, где начинается любой символ, отличный от цифры, притом ввод считается успешным только если мы встретили ```\0```. После отлова очевидных ошибок необходимо вычислить итоговый порядок числа.

Во-первых, если мы встретили знак ```-``` - меняем знак самого порядка (потому что до этого момента в памяти мы хранили положительное число). Во-вторых рассчет итогового порядка. Возможны варианты:
* если в считываемом числе есть целая часть (цифры перед точкой кроме 0), то порядок, очевидно, сумма количества этих цифр и самого порядка
* если в считываемом числе нет целой части, то порядок будет высчитываться как считанное после E значение порядка
минус **лидирующие** нули после точки минус, собственно, длина мантиссы

Для лучшего понимания вычисления итогового порядка рекомендуется поэкспериментировать на листочке, чтобы улучшить понимание процесса.
