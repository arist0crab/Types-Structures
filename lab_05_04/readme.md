# Практическая вводная ЛР №5

Основная сложность ЛР5 заключается в написании именно функции симуляции заданного процесса, 
состоящего из системы массового обслуживания и очереди заявок. В зависимости от варианта очередей или обслуживающих
аппаратов может быть несколько. Разберем алгоритм симуляции обработки очередей заявок на примере варианта №4, т.к. 
при внимательном рассмотрении оказывается, что различия между реализациями алгоритмов незначительны.

## Разбор условия 

Попробуем доступно разобрать условие задачи: есть две очереди заявок. В одной очереди собираются 
заявки первого типа, в другой - второго. В обе очереди постоянно прибывают новые заявки, 
причем время прибывания следующей заявки в очередь выбирается случайно от ЧПТ значения N до M. 
То есть интервал времени для заявок первого типа T1 от 1 до 5, это значит что каждый раз новая заявка 
прибудет либо через 1 единицу времени (минимум), либо через 5 единиц времени (максимум), 
либо между этими значениями, т.е. через 2.23443 е.в. (единиц времени), через 4.9934 е.в. и т.д. 
Для заявок второго типа это интервал T2 от 0 до 3 е.в. 

> [!IMPORTANT]
> Важно: единицы времени - ЭТО НЕ СЕКУНДЫ, это не микросекунды, не наносекунды. Это никакие секунды.
> Это условная единица времени. Ровно так же как пакет молока - тоже условная единица молока.
> Мы будем мерить время в симуляции с помощью этого "условного времени", но его значения стоит воспринимать
> (для простоты представления) как счетные палочки.

Также у нас есть обслуживающий аппарат (ОА). ОА обработывает заявки из обеих очередей по определенным
правилам. Заявка любого типа может войти в ОА, если:
1. она вошла в пустую систему;
2. перед ней обслуживалась заявка ее же типа;
3. перед ней из ОА вышла заявка другого типа, оставив за собой пустую очередь;

Заявки не обрабатываются в ОА мгновенно. Они обрабатываются за временные промежутки T3 и T4. Т.е. заявки 
первого типа обрабатываются от 0 до 4 е.в., а заявки второго типа обрабатываются от 0 до 1 е.в. 

> [!NOTE]
> 
> Обобщая, получаем следующие интервалы времени:
> - T1 [1; 5] - интервал поступлений заявок 1ого типа
> - T2 [0; 3] - интервал поступлений заявок 2ого типа
> - T3 [0; 4] - интервал обработки заявок 1ого типа
> - T4 [0; 1] - интервал обработки заявок 2ого типа

<img width="817" height="186" alt="image" src="https://github.com/user-attachments/assets/59a79934-fb93-4333-8090-5541a4bea032" />

Собственно, задача: смоделировать процесс обслуживания первых 1000 заявок первого типа. То есть по сути 
нужно смоделировать процесс обработки заявок по условию, чтобы они поступали в очереди, обрабатывались ОА, но 
до тех пор, пока ОА не "выпустит" 1000 заявок первого типа.

## Разбор алгоритма воспроизведения симуляции

Теперь рассмотрим сам алгоритм воспроизведения такой симуляции на примере симуляции для статического массива.
Сигнатура функции, которая этим занимается ниже:

```c
/** @brief Функция для симуляции работы системы (обработки n-time раз записей 1-ого типа) на 
 * основе работы со статическим массивом для хранения очередей.
 * @param verbose_mode Режим работы функции. При verbose_mode=true выводит информацию
 * о симуляции в терминал.
 * @return Статус выполнения функции.
*/
status_t simulate_service_unit_by_arr(bool verbose_mode);
```

### Шаг 1. Инициализация барахла

```c
status_t ec = SUCCESS_CODE;

// инициализируем очереди и их логи
arr_queue_t queue1 = { 0 }, queue2 = { 0 };
simulation_log_t log1 = { 0 }, log2 = { 0 };
size_t last_print_checkpoint = 0;

double current_time = 0.0;  // "виртуальное" (модельное) время
double next_event_time = 0.0;  // время следующего события
double current_service_end_time = INFINITY;  // время, когда закончится текущее обслуживание

// временные переменные
double temp_time = 0.0;
double system_downtime = 0.0;  // время простоя системы
double next_arrival_type1 = 0.0, next_arrival_type2 = 0.0;
random_double(arrival_time_of_type_1.min_time, arrival_time_of_type_1.max_time, &next_arrival_type1);
random_double(arrival_time_of_type_2.min_time, arrival_time_of_type_2.max_time, &next_arrival_type2);

request_t current_request = { 0 };  // текущая заявка
request_t popped_request = { 0 };  // заявка, которая будет удаляться
request_class_t last_served_type = TYPE_1;  // тип последней обслуживаемой заявки
```

Для начала необходимо инициализировать все переменные, структуры, маркеры, которые нам будут нужны. Пробежимся 
по достопримечательностям:
- Сначала инициализируются очереди и их логи. Что такое логи? Логи - это записи событий, которые конкретно
  в нашем случае будут происходить в симуляции:
  ```c
  typedef struct
  {
      size_t request_in_count;  // кол-во заявок, которые вошли в систему
      size_t request_out_count;  // кол-во заявок, которые вышли из системы
      size_t failed_request_count;  // кол-во потерянных заявок
      size_t function_call_count;  // кол-во обращений к ОА
      double total_length;  // суммарная длина очереди на момент извлечения каждой заявки
      double total_wait_time;  // суммарное время ожидания всех заявок в очереди
  } simulation_log_t;
  ```
  Таких логов у нас будет два для двух очередей соответственно. Переменная ```last_print_checkpoint```
  будет фигурировать чуть позже. Сейчас ее можно опустить.
- Временные переменные. Это один из самых сложных моментов понимания логики работы алгоритма.
  ```current_time``` - это наш виртуальный "секундомер". Т.е. наше виртуальное время начинает течь
  с момента запуска функции и в начале запуска оно всегда будет 0, а потом будет увеличиваться,
  потому что время в нашей симуляции уверенно течет. ```next_event_time``` - это как виртуальный будильник.
  В эту переменную мы будет записывать время до следующего ближайшего события. Причем мы записываем не СКОЛЬКО
  осталось до события, а ВО СКОЛЬКО оно произойдет по нашим внутренним часам.
  ```current_service_end_time``` - это время когда ОА закончит обслуживать текущую заявку. Опять-таки, не
  СКОЛЬКО осталась до конца ее обслуживания, а ВО СКОЛЬКО он закончит ее обрабатывать. ```temp_time``` - это
  переменная, которая нужна для того, чтобы записывать в нее случайное время, а потом производить с ней какие-то
  действия, пока ее также можно опустить. ```system_downtime``` - это время простоя системы. Например, ОА только
  что закончил обрабатывать заявку. Следующая заявка первого типа придет через 3 е.в., а заявка второго типа
  придет через 2 е.в. Это значит, что 2 е.в. ОА будет простаивать. Это время мы будем высчитывать именно в
  ```system_downtime```, т.к. оно тоже нужно нам для статистики. ```next_arrival_type1``` и
  ```next_arrival_type2``` - это ВО СКОЛЬКО прибудет следующая заявка первого и второго типа соответственно.
  В строчках ниже мы присваиваем этим переменным случайные значения в необходимом диапазоне:
  ```c
  random_double(arrival_time_of_type_1.min_time, arrival_time_of_type_1.max_time, &next_arrival_type1);
  random_double(arrival_time_of_type_2.min_time, arrival_time_of_type_2.max_time, &next_arrival_type2);
  ```
  В общем, важно обратить внимание, что мы вообще не храним время в стиле СКОЛЬКО ОСТАЛОСЬ до события, мы храним
  его в в формате ВО СКОЛЬКО это событие случится.

### Шаг 2. Основной цикл

Все действия нашей уютной симуляции будут просиходить в следующем уютном цикле:

```c
while (ec == SUCCESS_CODE && log1.request_out_count < REQUESTS_1_TYPE_QUEUE_LENGTH)
{
    // определяем ближайшее событие
    min3(next_arrival_type1, next_arrival_type2, current_service_end_time, &next_event_time);
    current_time = next_event_time;

    // СОБЫТИЯ СИМУЛЯЦИИ...
    // СОБЫТИЯ СИМУЛЯЦИИ...
    // СОБЫТИЯ СИМУЛЯЦИИ...
}
```

Итак, как было понятно из условия, симуляция будет симулироваться пока ОА не насимулирует 1000 заявок первого
типа (```log1.request_out_count < REQUESTS_1_TYPE_QUEUE_LENGTH```), также в процессе могут возникнуть ошибки, 
поэтому каждую итерацию проверяем как у нас идут дела (```ec == SUCCESS_CODE```).

Функция ```min3``` находит наименьшее из трех переменных и записывает результат в последнюю четвертую переменную.
То есть в нашем случае мы хотим определить ближайшее событие (т.е. наименьшее по времени). В нашей симуляции
возможно только 3 события:
- поступление заявки первого типа
- поступление заявки второго типа
- окончание обработки какой-либо заявки в ОА

То событие, которое наступит быстрее, мы определяем в переменную ```next_event_time``` и дальше отталкиваемся
от него. Далее мы сразу переводим наши "виртуальные часы" на момент нового ближайщего события в строчке
```c current_time = next_event_time;```

