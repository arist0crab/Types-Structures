# Практическая вводная ЛР №5

Основная сложность ЛР5 заключается в написании именно функции симуляции заданного процесса, 
состоящего из системы массового обслуживания и очереди заявок. В зависимости от варианта очередей или обслуживающих
аппаратов может быть несколько. Разберем алгоритм симуляции обработки очередей заявок на примере варианта №4, т.к. 
при внимательном рассмотрении оказывается, что различия между реализациями алгоритмов незначительны.

## Разбор условия 

Попробуем доступно разобрать условие задачи: есть две очереди заявок. В одной очереди собираются 
заявки первого типа, в другой - второго. В обе очереди постоянно прибывают новые заявки, 
причем время прибывания следующей заявки в очередь выбирается случайно от ЧПТ значения N до M. 
То есть интервал времени для заявок первого типа T1 от 1 до 5, это значит что каждый раз новая заявка 
прибудет либо через 1 единицу времени (минимум), либо через 5 единиц времени (максимум), 
либо между этими значениями, т.е. через 2.23443 е.в. (единиц времени), через 4.9934 е.в. и т.д. 
Для заявок второго типа это интервал T2 от 0 до 3 е.в. 

> [!IMPORTANT]
> Важно: единицы времени - ЭТО НЕ СЕКУНДЫ, это не микросекунды, не наносекунды. Это никакие секунды.
> Это условная единица времени. Ровно так же как пакет молока - тоже условная единица молока.
> Мы будем мерить время в симуляции с помощью этого "условного времени", но его значения стоит воспринимать
> (для простоты представления) как счетные палочки.

Также у нас есть обслуживающий аппарат (ОА). ОА обработывает заявки из обеих очередей по определенным
правилам. Заявка любого типа может войти в ОА, если:
1. она вошла в пустую систему;
2. перед ней обслуживалась заявка ее же типа;
3. перед ней из ОА вышла заявка другого типа, оставив за собой пустую очередь;

Заявки не обрабатываются в ОА мгновенно. Они обрабатываются за временные промежутки T3 и T4. Т.е. заявки 
первого типа обрабатываются от 0 до 4 е.в., а заявки второго типа обрабатываются от 0 до 1 е.в. 

> [!NOTE]
> 
> Обобщая, получаем следующие интервалы времени:
> - T1 [1; 5] - интервал поступлений заявок 1ого типа
> - T2 [0; 3] - интервал поступлений заявок 2ого типа
> - T3 [0; 4] - интервал обработки заявок 1ого типа
> - T4 [0; 1] - интервал обработки заявок 2ого типа

<img width="817" height="186" alt="image" src="https://github.com/user-attachments/assets/59a79934-fb93-4333-8090-5541a4bea032" />

Собственно, задача: смоделировать процесс обслуживания первых 1000 заявок первого типа. То есть по сути 
нужно смоделировать процесс обработки заявок по условию, чтобы они поступали в очереди, обрабатывались ОА, но 
до тех пор, пока ОА не "выпустит" 1000 заявок первого типа.

## Разбор алгоритма воспроизведения симуляции

Теперь рассмотрим сам алгоритм воспроизведения такой симуляции на примере симуляции для статического массива.
Сигнатура функции, которая этим занимается ниже:

```c
/** @brief Функция для симуляции работы системы (обработки n-time раз записей 1-ого типа) на 
 * основе работы со статическим массивом для хранения очередей.
 * @param verbose_mode Режим работы функции. При verbose_mode=true выводит информацию
 * о симуляции в терминал.
 * @return Статус выполнения функции.
*/
status_t simulate_service_unit_by_arr(bool verbose_mode);
```

### Шаг 1. Инициализация барахла

```c
status_t ec = SUCCESS_CODE;

// инициализируем очереди и их логи
arr_queue_t queue1 = { 0 }, queue2 = { 0 };
simulation_log_t log1 = { 0 }, log2 = { 0 };
size_t last_print_checkpoint = 0;

double current_time = 0.0;  // "виртуальное" (модельное) время
double next_event_time = 0.0;  // время следующего события
double current_service_end_time = INFINITY;  // время, когда закончится текущее обслуживание

// временные переменные
double temp_time = 0.0;
double system_downtime = 0.0;  // время простоя системы
double next_arrival_type1 = 0.0, next_arrival_type2 = 0.0;
random_double(arrival_time_of_type_1.min_time, arrival_time_of_type_1.max_time, &next_arrival_type1);
random_double(arrival_time_of_type_2.min_time, arrival_time_of_type_2.max_time, &next_arrival_type2);

request_t current_request = { 0 };  // текущая заявка
request_t popped_request = { 0 };  // заявка, которая будет удаляться
request_class_t last_served_type = TYPE_1;  // тип последней обслуживаемой заявки
```

Для начала необходимо инициализировать все переменные, структуры, маркеры, которые нам будут нужны. Пробежимся 
по достопримечательностям:
- Сначала инициализируются очереди и их логи. Что такое логи? Логи - это записи событий, которые конкретно
  в нашем случае будут происходить в симуляции:
  ```c
  typedef struct
  {
      size_t request_in_count;  // кол-во заявок, которые вошли в систему
      size_t request_out_count;  // кол-во заявок, которые вышли из системы
      size_t failed_request_count;  // кол-во потерянных заявок
      size_t function_call_count;  // кол-во обращений к ОА
      double total_length;  // суммарная длина очереди на момент извлечения каждой заявки
      double total_wait_time;  // суммарное время ожидания всех заявок в очереди
  } simulation_log_t;
  ```
  Таких логов у нас будет два для двух очередей соответственно. Переменная ```last_print_checkpoint```
  будет фигурировать чуть позже. Сейчас ее можно опустить.
- Временные переменные. Это один из самых сложных моментов понимания логики работы алгоритма.
  ```current_time``` - это наш виртуальный "секундомер". Т.е. наше виртуальное время начинает течь
  с момента запуска функции и в начале запуска оно всегда будет 0, а потом будет увеличиваться,
  потому что время в нашей симуляции уверенно течет. ```next_event_time``` - это как виртуальный будильник.
  В эту переменную мы будет записывать время до следующего ближайшего события. Причем мы записываем не СКОЛЬКО
  осталось до события, а ВО СКОЛЬКО оно произойдет по нашим внутренним часам.
  ```current_service_end_time``` - это время когда ОА закончит обслуживать текущую заявку. Опять-таки, не
  СКОЛЬКО осталась до конца ее обслуживания, а ВО СКОЛЬКО он закончит ее обрабатывать. ```temp_time``` - это
  переменная, которая нужна для того, чтобы записывать в нее случайное время, а потом производить с ней какие-то
  действия, пока ее также можно опустить. ```system_downtime``` - это время простоя системы. Например, ОА только
  что закончил обрабатывать заявку. Следующая заявка первого типа придет через 3 е.в., а заявка второго типа
  придет через 2 е.в. Это значит, что 2 е.в. ОА будет простаивать. Это время мы будем высчитывать именно в
  ```system_downtime```, т.к. оно тоже нужно нам для статистики. ```next_arrival_type1``` и
  ```next_arrival_type2``` - это ВО СКОЛЬКО прибудет следующая заявка первого и второго типа соответственно.
  В строчках ниже мы присваиваем этим переменным случайные значения в необходимом диапазоне:
  ```c
  random_double(arrival_time_of_type_1.min_time, arrival_time_of_type_1.max_time, &next_arrival_type1);
  random_double(arrival_time_of_type_2.min_time, arrival_time_of_type_2.max_time, &next_arrival_type2);
  ```
  В общем, важно обратить внимание, что мы вообще не храним время в стиле СКОЛЬКО ОСТАЛОСЬ до события, мы храним
  его в в формате ВО СКОЛЬКО это событие случится.

### Шаг 2. Основной цикл

Все действия нашей уютной симуляции будут просиходить в следующем уютном цикле:

```c
while (ec == SUCCESS_CODE && log1.request_out_count < REQUESTS_1_TYPE_QUEUE_LENGTH)
{
    // определяем ближайшее событие
    min3(next_arrival_type1, next_arrival_type2, current_service_end_time, &next_event_time);
    current_time = next_event_time;

    // СОБЫТИЯ СИМУЛЯЦИИ...
    // СОБЫТИЯ СИМУЛЯЦИИ...
    // СОБЫТИЯ СИМУЛЯЦИИ...
}
```

Итак, как было понятно из условия, симуляция будет симулироваться пока ОА не насимулирует 1000 заявок первого
типа (```log1.request_out_count < REQUESTS_1_TYPE_QUEUE_LENGTH```), также в процессе могут возникнуть ошибки, 
поэтому каждую итерацию проверяем как у нас идут дела (```ec == SUCCESS_CODE```).

Функция ```min3``` находит наименьшее из трех переменных и записывает результат в последнюю четвертую переменную.
То есть в нашем случае мы хотим определить ближайшее событие (т.е. наименьшее по времени). В нашей симуляции
возможно только 3 события:
- поступление заявки первого типа
- поступление заявки второго типа
- окончание обработки какой-либо заявки в ОА

То событие, которое наступит быстрее, мы определяем в переменную ```next_event_time``` и дальше отталкиваемся
от него. Далее мы сразу переводим наши "виртуальные часы" на момент нового ближайщего события в строчке
```c current_time = next_event_time;```

## Шаг 3. Обработка событий

Вопрос в том, как определять, какое именно событие мы должны обрабатывать  каждую итерацию цикла. Да, у нас есть переменная ```next_event_time```, которая хранит время следующего события, но она не хранит информацию о том какое именно это будет событие. Все относительно просто: чтобы понять, какое именно из трех событий сейчас должно произойти, для для каждого события вычесть из времени его наступления ```next_event_time```. Если разница равна нулю, то время наступления события и время самого ближайщего события одинаковы, следовательно, совпадают. Рассмотрим на блоке ниже:

```c
// если появилась заявка типа 1
if (fabs(next_arrival_type1 - next_event_time) < EPS)
{
    current_request.request_class = TYPE_1;
    current_request.arrival_time = current_time;

    if (queue1.size < MAX_QUEUE_SIZE)
        push_arr(&queue1, &current_request);
    else 
        log1.failed_request_count++;

    if (current_service_end_time == INFINITY)
    {
        random_double(service_time_of_type_1.min_time, service_time_of_type_1.max_time, &temp_time);
        current_service_end_time = current_time + temp_time;
    }
    
    log1.request_in_count++;
    random_double(arrival_time_of_type_1.min_time, arrival_time_of_type_1.max_time, &temp_time);
    next_arrival_type1 += temp_time;
}
```

Условие ```if (fabs(next_arrival_type1 - next_event_time) < EPS)``` как раз проверяет равенство 
```next_arrival_type1``` и ```next_event_time```. Если они равны, значит следующее событие - поступление заявки первого типа. Присваиваем поступающей заявке соответствующие поля:

```c
current_request.request_class = TYPE_1;
current_request.arrival_time = current_time;
```

Если очередь не переполнена, мы можем засунуть в нее новую заявку, в противном случае она будет потеряна:

```c
if (queue1.size < MAX_QUEUE_SIZE)
    push_arr(&queue1, &current_request);
else 
    log1.failed_request_count++;
```

Про блок с условием ```if (current_service_end_time == INFINITY)``` пояснение будет далее, сейчас логичнее увеличить счетчик поступивших заявок первого типа, выбрать cooldown до нового прибытия заявки первого типа и обновить ```next_arrival_type1```:

```c
log1.request_in_count++;
random_double(arrival_time_of_type_1.min_time, arrival_time_of_type_1.max_time, &temp_time);
next_arrival_type1 += temp_time;
```

Отдельно стоит рассмотреть следующий блок:

```c
if (current_service_end_time == INFINITY)
{
    random_double(service_time_of_type_1.min_time, service_time_of_type_1.max_time, &temp_time);
    current_service_end_time = current_time + temp_time;
}
```

Дело в том что при инициализации мы указывали ```double current_service_end_time = INFINITY;```, чтобы при первой итерации ```while``` переменная ```current_service_end_time``` никак не могла быть минимальной, потому что (сюрприз-сюрприз), когда мы запускаем нашу симуляцию, самым первым событием так или иначе должно быть поступление какой-либо заявки, но никак не ее обработка. Также, когда ОА простаивает, никакая заявка не находится в обработке, значит ```current_service_end_time``` следует назначить значение ```INFINITY```. Так вот, случаи, когда ```current_service_end_time == INFINITY``` (т.е. по сути это моменты времени, когда ОА не работает и мы ждем новой заявки, которая моментально поступит в обработку) необходимо корректно обрабатывать, иначе оно никогда не поменяет своего значения и цикл станет бесконечным. Именно поэтому в строчке ```current_service_end_time = current_time + temp_time;``` мы, по сути, назначаем время окончания обработки только что поступившей заявки. Это сложный, но важный момент.

Блок обработки события "поступление заявки второго типа" фактически ничем не отличается от такого же блока для заявок первого типа, поэтому следующая точка интереса - событие "завершение обслуживания".

```c
// если завершилось обслуживание (пытаемся обработать как можно скорее заявки первого типа)
else if (fabs(current_service_end_time - next_event_time) < EPS)
{
    if (queue1.size && (queue2.size == 0 || last_served_type == TYPE_1))
    {
        pop_arr(&queue1, &popped_request);
        log1.request_out_count++;
        log1.total_wait_time += current_time - popped_request.arrival_time;
        log1.total_length += queue1.size;
        random_double(service_time_of_type_1.min_time, service_time_of_type_1.max_time, &temp_time);
        current_service_end_time = current_time + temp_time;
        last_served_type = TYPE_1;
    }
    else if (queue2.size && (queue1.size == 0 || last_served_type == TYPE_2))
    {
        pop_arr(&queue2, &popped_request);
        log2.request_out_count++;
        log2.total_wait_time += current_time - popped_request.arrival_time;
        log2.total_length += queue2.size;
        random_double(service_time_of_type_2.min_time, service_time_of_type_2.max_time, &temp_time);
        current_service_end_time = current_time + temp_time;
        last_served_type = TYPE_2;
    }
    else if (queue1.size == 0 && queue2.size == 0)
    {
        system_downtime += (fmin(next_arrival_type1, next_arrival_type2) - current_time);
        current_service_end_time = INFINITY;
    }

    log1.function_call_count++;
    log2.function_call_count++; 
}
```

Итак, вот обслуживание нашей заявки подошло к концу, про обработанную заявку мы радостно забываем: теперь система свободна, значит, мы можем просунуть следующую заявку в обработку. Наш приоритет - заявки первого типа, именно их мы пытаемся запихать побольше в ОА. Строчка ```if (queue1.size && (queue2.size == 0 || last_served_type == TYPE_1))``` проверяет условие "можем ли мы запихнуть заявку первого типа в ОА", если можем, то берем заявку из очереди первого типа (```pop_arr(&queue2, &popped_request);```), обновляем логи надлежащим образом и меняем переменную ```last_served_type = TYPE_1;```. Также назначаем новый ```temp_time``` и ```current_service_end_time = current_time + temp_time;```.

Если обработать заявку первого типа мы не можем, то пытаемся обработать заявку второго (по аналогии с первой, они почти идентичны). Если и этого мы сделать не можем то, остается только рассмотреть вариант, при котором ```queue1.size == 0 && queue2.size == 0``` (спойлер: это все возможные оставшиеся случаи). Очевидно, заявок нет, в ОА положить нечего, система простаивает: ```system_downtime += ...```, а т.к. система простаивает, необходимо выполнить ```current_service_end_time = INFINITY;``` по причинам, рассмотренным выше. 

## Шаг 4. Печать результатов и завершение симуляции

По условию каждые 100 обработанных заявок первого типа нам необходимо выводить информацию о том, как идут дела в симуляции. Делаем мы это только в том случае, если ```verbose_mode == true``` и ```last_print_checkpoint != log1.request_out_count```:

```c
// каждые 100 записей печатаем промежуточную информацию
if (verbose_mode && log1.request_out_count % 100 == 0 && last_print_checkpoint != log1.request_out_count)
{
    print_interim_results_table_content_list(&queue1, &log1, &queue2, &log2);
    last_print_checkpoint = log1.request_out_count;
}
```

Последнее условие необходимо для того, чтобы некоторые строки таблицы не выводились дважды. Например, ОА только что выпустил 100 заявок первого типа. А потом в ОА поступила заявка второго типа, он ее успешно обработал и... обработанных заявок первого типа все еще 100 штук. Информация о процессе печатается дважды, информация в таблице дублируется. А вот ```last_print_checkpoint``` хранит в себе кол-во заявок первого типа, при котором последний раз была напечатана отладочная информация. Т.е. если мы единожды печатаем информацию на 100 заявках, то в следующий раз условие ```last_print_checkpoint != log1.request_out_count``` не допустит этого.

После выхода из основного цикла просто печатаем еще раз всю важную информацию, подводя итоги:

```c
if (verbose_mode)
{
    print_interim_results_table_bottom();
    print_simulation_summary(current_time, &log1, &log2, system_downtime);
}
```

Собственно, это был буквально весь принцип работы алгоритма симуляции :)
