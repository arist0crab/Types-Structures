# Теоретичекая вводная ЛР №3

## Разреженные матрицы

Для начала определим центральное понятие лабораторной работы №3:

> [!IMPORTANT]
> 
> Разреженные матрицы - это матрицы, в которых большая часть элементов — НУЛИ
> 
> Плотные матрицы - это матрицы, в которых большая часть элементов — НЕ НУЛИ
> 
> Элементы матрицы, которые не являются нулями, называются ненулевыми или значимыми элементами

Вполне очевидно, что хранить большую разреженную матрицу в памяти компьютера так, как мы делаем это обычно, не рационально. Вот разреженная матрица 5x5:

```
[0, 5, 0, 0, 0]
[0, 0, 0, 0, 0]
[0, 0, 0, 0, 0]
[0, 0, 0, 0, 1]
[0, 0, 0, 0, 0]
```

Каждое число (типа integer) будет занимать в памяти в среднем 4 байта. Всего для "стандартного" хранения в памяти такой матрицы понадобится ```25*4=100 байт```, в то время как действительно важны для нас всего два цисла: 5 и 1 (потому что остальные - нули), и эти два числа будут занимать в памяти ```4*2=8 байт```. Перерасход памяти очевиден: в данном случае нам необходимо всего 8% памяти от реально затрачиваемой.

Также вполне очевидно, что если стандартными методами перемножить две разреженные матрицы размером 1000x1000, то в результате перемножения тонн нулей между собой будет затрачен не только ресурс, но и лишнее время: 0 на 0 всегда 0, нет никакого смысла проверять это снова и снова.

Обычные алгоритмы перемножения матриц подходят для плотных матриц: в них небольшой процент нулевых элементов и мы никак не можем избежать ни их хранения "целиком", ни их перемножения "лоб в лоб".

Алгоритмы обработки разреженных матриц предполагают действия только с
ненулевыми элементами и, таким образом, количество операций будет
пропорционально количеству ненулевых элементов, а значит, это оптимальные алгоритмы.

Хорошо, мы хотим избежать больших как ресурсных, так и временных затрат на работу с разреженными матрицами: как оптимизировать работу с ними? Рассмотрим два варианта хранения разреженных матриц, которые помогают значительно сократить объемы памяти для хранения данных в памяти, оба предполагают, что изначально одну большую матрицу мы будем разбивать на 3 списка (массива), которые будут содержать информацию. Достаточную информацию, чтобы по ней восстановить всю исходную матрицу, а главное - эффективно их перемножать.

# CSR (Compressed Sparse Row)

Первый предложенный формат хранения - CSR, то есть формат хранения по строкам.

> [!NOTE]
>
> Для наглядности форматы хранения будут рассматриваться на небольших матрицах, чтобы была очевидна логика представления таких матриц в указанном виде

Рассмотрим три массива, необходимых для хранения данных о матрице.

## Массив A - "Что храним?"

Массив А является массивом "значений" матрицы, то есть по сути массив всех НЕНУЛЕВЫХ элементов, записанных ПО СТРОКАМ (как мы читаем книги, например). Например, имеем следующую марицу:

```
[1, 2, 0]
[0, 4, 0]
[0, 2, 6]
```

Тогда массив A (массив значений) для данной матрицы:

```
A[] = [1, 2, 4, 2, 6]
```

## Массив JA - "В каком столбце?"

Массив JA - это массив **индексов столбцов** НЕНУЛЕВЫХ элементов. На слух такое опредление воспринимается с трудом, поэтому расмотрим логику на примере матрицы выше. Т.к. формат CSR - формат хранения по строкам, индексы **строк** ненулевых элементов нас не интересуют, а интересуют только столбцы, как бы странно это ни звучало.

* первый ненулевой элемент 1 находится в столбце с индексом 0
* второй (то есть 2) - в столбце с индексом 1
* третий (т.е. 4) - тоже в столбце с индексом 1
* четвертый (т.е. 2) в столбце с индексом 1
* последний элемент (т.е. 6) находится в столбце с индексом 2

Теперь собираем массив JA:

```
JA[] = [0, 1, 1, 1, 2]
```

Итак, в массиве JA хранится индекс столбца каждого ненулевого элемента матрицы.

## Массив IA - "Индексация строк"

На этом моменте может стать любопытно: где в "формате хранения по строкам", собственно, сами строки или какая-либо работа с ними? Так вот массив IA как раз предполагает строковую обработку, но не совсем и не сразу интуитивно понятную.

> [!IMPORTANT]
> Маcсив IA  - массив индексации строк. Если в разреженной матрице N ненулевых элементов, то в массиве IA N+1 элементов. Элемент массива IA с индексом i хранит количество ненулевых элементов от начала массива до строки i-1 включительно. Таким образом первый элемент массива IA всегда 0, а последний элемент массива равняется количеству ненулевых элементов в исходной матрице.

Разберем на примере нашей вышеуказанной матрицы:

```
[1, 2, 0]
[0, 4, 0]
[0, 2, 6]
```

* до нулевой строки нашей матрицы (очевидно) содержится 0 значимых (ненулевых) элементов
* до первой строки матрицы (т.е. в нулевой строке) содержится 2 значимых элемента
* до второй строки (т.е. в нулевой + первой строке) содержится 2+1=3 значимых элемента
* всего в матрице содержится (нулевая + первая + вторая строка) 2+1+2=5 значимых элементов

Таким образом, собирая весь анализ в один массив, получим массив IA:

```
IA[] = [0, 2, 3, 5]
```

# Как этим пользоваться?

> [!IMPORTANT]
> Чтобы найти все элементы строки с **индексом** i:
>
> 1. Находим ```start``` и ```end```, которые соответственно равны ```IA[i]``` и ```IA[i+1]-1```.
> 
> 2. Проходимся от ```start``` до ```end``` включительно (пусть это будет индекс ```j```), тогда значения элементов в строке ```i``` будут равны ```A[j]```, а индексы столбцов ```JA[j]```.

Разберем на примере следующей матрицы:

```
Строка 0: [5, 0, 0, 8]
Строка 1: [2, 0, 4, 6]
Строка 2: [0, 3, 0, 0]
```

Будем искать элементы строки с индексом 1.

1. **Записываем в CSR формате**

```
  A (значения): [5, 8, 2, 4, 6, 3]
  JA (столбцы): [0, 3, 0, 2, 3, 1]
IA (указатели): [0, 2, 5, 6]
```

2. **Находим start и end**

```
start = IA[1] = 2
end = IA[1+1] - 1 = 5 - 1 = 4
```

3. **Находим все элементы нужной строки**

    * ```j = 2 (start)```. Значение первого элемента первой строки: ```A[2] = 2```, индекс столбца: ```JA[2] = 0```
    * ```j = 3``` (идем от ```start``` до ```end```). Значение второго элемента первой строки: ```A[3] = 4```, индекс столбца: ```JA[3] = 2```
    * ```j = 4 (end)```. Значение второго элемента первой строки: ```A[4] = 6```, индекс столбца: ```JA[4] = 3```

# Почему это работает?

На первый взгляд алгоритм работы с таким форматом представления матрицы - это чей-то сон при температуре 39, который по каким-то непонятным соображениям оказывается абсолютно рабочим. Однако если заставить себя рассмотреть данный метод работы повторно, он становится вполне логичным, и единственный вопрос, который остается после этого интеллектального подвига: как такое вообще кому-то пришло в голову?

Когда мы ищем все элементы строки ```i``` и берем ```start = IA[i]```, то оказывается, что ```start``` - это количество значимых элементов матрицы, которое содержится в ней ДО интересующей нас строки, а значит, фактически, это ни что иное как ИНДЕКС первого значимого элемента строки ```i``` среди всех значимых элементов матрицы. Есть ли у нас массив, который содержит все значимые элементы матрицы? М... Да, есть! Это массив A. То есть ```A[i]``` будет указывать на значение первого значимого элемента в строке ```i```, а индекс столбца по такой же логике будет в массиве, который по порядку хранит в себе индексы столбцов для каждого значимого элемента матрицы (подсказка: это массив JA).

С первым значимым элементом строки с индексом ```i``` разобрались, что с остальными? Почему ```end = IA[i+1] - 1```? Итак, возьмем строку с индексом ```i+1```. Мы уже знаем, что чтобы найти первый значимый элемент  в строке с индексом ```i+1``` нужно взять ```IA[i+1]```. Здесь очень важно осознать в полной мере, что раз ```IA[i+1]``` - это индекс ПЕРВОГО элемента строки ```i+1```, то чтобы найти индекс ПОСЛЕДНЕГО элемента строки ```i``` нужно просто отнять из индекса ПЕРВОГО элемента единицу, что и есть ```IA[i+1] - 1```. А все значения между ```A[i]``` и ```IA[i+1] - 1``` - это индексы ВСЕХ элементов в строке с индексом ```i```. Дальше по кругу: находим индекс, берем значение, берем индекс столбца. А индекс строки у нас и так уже есть (мы по нему и ищем как раз).

# CSC (Compressed Sparse Column)

Второй предложенный формат хранения - CSC, то есть формат хранения по столбцам.

Несложно догадаться, что CSC очень похож на CSR, однако он оптимизирован для доступа к столбцам матрицы. Для его реализации нам понядобятся все те же три массива:

* A (значения)
* IA (строки)
* JA (столбцы)

Так как формат CSR был рассмотрен крайне подробно, обзор CSC буден ограничен демонстративным примером работы с CSC, потому как и идея, и логика реализации у обоих форматов почти полностью повторяет друг друга. Просто здесь столбцы заменяют строки (соответственно здесь матрицу необходимо просматривать ПО СТОЛБЦАМ, китайцы, например, так пишут и читают).

Пример:

```
Строка 0: [5, 0, 0, 8]
Строка 1: [0, 0, 4, 0]
Строка 2: [1, 0, 7, 0]
Строка 3: [0, 3, 0, 0]
```

```
  A (значения): [5, 1, 3, 4, 7, 8]
JA (указатели): [0, 2, 3, 5, 6]
   IA (строки): [0, 2, 3, 1, 2, 0]
```

> [!IMPORTANT]
> Алгоритм поиска значений и их индексов по столбцу ```i``` у CSC формата (который зеркален CSR формату) неожиданно зеркален такому же алгоритму для CSR формата, то есть:
> 
> 1. Находим ```start``` и ```end```, которые соответственно равны ```JA[i]``` и ```JA[i+1]-1```.
> 
> 2. Проходимся от ```start``` до ```end``` включительно (пусть это будет индекс ```j```), тогда значения элементов в столбце ```i``` будут равны ```A[j]```, а индексы строк ```IA[j]```.

Найдем все значения столбца с индексом 3:

1. ```start = JA[3] = 5``` и ```end = JA[3+1] - 1 = 6 - 1 = 5```
2. От 5 до 5 всего 1 число - сама 5. То есть в столбце 3 всего 1 элемент. Найдем его: ```A[5] = 8```, ```IA[5] = 0```

Таким образом в столбце с индексом 3 в строке с индексом 0 содержится единственный в этом столбце значимый элемент - 8.